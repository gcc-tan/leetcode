###Manacher算法


首先没有理解这个算法，然后感觉非常吃力，理解了之后就感觉简单了不少。这个算法是用来查找字符串中最长回文子串（`abb的最长回文子串是bb，abac最长回文子串是aba`）的时间复杂度为O(n)的算法。其实这个算法是和常见的时间复杂度为O(n^2)的中心扩展（就是以一个字符或者两个字符为中心，向两边扩展）的算法思想一致，只是加入了已经扩展的回文串的信息用来加速扩展。


在讲解算法前定义几个变量：

+ 字符串s，这是输入的目标字符串"122122"	
+ 数组ma，预处理之后的字符串。在原始字符串前后，还有中间间隔位置加入目标字符串里不出现的特殊字符，如‘#’。s经过预处理之后变为“#1#2#2#1#2#2#”。(预处理的作用是将两个字符为中心的回文串abba变成一个字符为中心，能够进行一样的扩展处理)
+ 数组mp，代表以i为中心的最长回文串的半径。(这个数组很关键，这个求出来之后关于回文串的位置和长度信息都能够求得)
+ 变量mx   ：代表当前“已经匹配完毕的结尾最远的回文串”到达了ma[]数组的第mx位。
+ 变量id    ：代表当前“已经匹配完毕的结尾最远的回文串”中心为ma[]数组的第id位。

```
下面这个例子就是ma，与对应的mp数组
# 1 # 2 # 2 # 1 # 2 # 2 #
1 2 1 2 5 2 1 6 1 2 3 2 1
```
先给出一段核心代码
```
int i,id = 0,mx = 0;
for(i = 0; i < len; ++i)
{
	mp[i] = mx > i ? min(mp[2*id-i],mx - i) : 1;
	while(ma[i+mp[i]] == ma[i-mp[i]]) mp[i]++;
	if(i + mp[i] > mx)
	{
		mx = i + mp[i];
		id = i;
	}
}
```
关键就是这行代码的理解，`mp[i] = mx > i ? min(mp[2*id-i],mx - i) : 1;`。

1. 代码的首先进行对当前i的位置进行判断，如果i在已经确认回文串的最远端的右侧，就是i >= mx的情况，这种情况没法对mp的半径进行预测，只能够返回默认长度1，然后使用接下来的while语句对mp进行暴力扩展。

2. 但是如果i在mx的范围内。那么i关于id的对称点j=2*id-1这个点的回文串长度信息已经有了。那么可以得到第一个下界mp[j](`其实不光是下界，是mp[i]=mp[j])`，这个下界的前提条件是以j为中心的回文串在以id为中心的回文串里面。但是还会出现以j为中心的回文串不完全在以id为中心的回文串里面。这个时候能保证的就是mp[i]肯定像j一样扩展到边界，即另外一个下界mx-i。

给出上面2中两种情况的图解。底下的线段表示回文串的范围

![e1](img/manacher1.png)

![e2](img/manacher2.png)




最后还有一个关于时间复杂度的问题。while的那层暴力扩展明明是O(n)的时间复杂度，而总的时间复杂度为O(n)呢？


1.  在i < mx的情况下，p的值可以在O(1)时间内确定

2.  在i >=mx的情况下，p的值需要O(n)的时间内确定，但是在情况2下，每次扫描都从mx开始，且mx自身的变化情况是单调递增的，这样可以保证，字符串中的每个字符最多被访问2次，所以，该算法的时间复杂度是线性O(n)

但是这里的mx，是不断往后走而不可能往前退的，它自身的值的变化是递增的。那么你可以明白，要进入while循环，i的值必然是比mx大的，也就是说整个程序结束为止，while循环执行的操作数为n次（线性次），而字符串中的每个字符，最多能被访问到2次。时间复杂度必然为O(n)


**参考**

[有什么浅显易懂的Manacher Algorithm讲解？](https://www.zhihu.com/question/37289584)

[Manacher's Algorithm 马拉车算法](http://www.cnblogs.com/grandyang/p/4475985.html)

[如何证明Manacher算法的时间复杂度是O(n)?](https://www.zhihu.com/question/30226229)
